<!DOCTYPE HTML>
<html lang="ko">
<head>
    <!-- # common resource # -->
    <link rel="shortcut icon" href="/images/favicon.ico">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0">
    <meta name="author" content="Jung DongMin">

    <!-- # css -->
    <link rel="stylesheet" type="text/css" href="/css/reset.css">
    <link rel="stylesheet" type="text/css" href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">

    <!-- # font -->
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/earlyaccess/nanumgothic.css">
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/earlyaccess/nanumgothiccoding.css">

    <!-- # jquery -->
    <!--[if lte IE 9]>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery-ajaxtransport-xdomainrequest/1.0.3/jquery.xdomainrequest.min.js"></script>
    <![endif]-->
    <!--[if gt IE 9]><!-->
    <script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
    <!--<![endif]-->

    <!-- # ad # -->    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>    <script>         (adsbygoogle = window.adsbygoogle || []).push({              google_ad_client: "ca-pub-4675654622926623",              enable_page_level_ads: true         });    </script>    <!-- # front view lib # -->
    <link rel="stylesheet" type="text/css" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

    <!-- # blog library # -->
    <link rel="stylesheet" type="text/css" href="/blog/css/view.css">
    <script src="/lib/o/1.0.2.min.js"></script>
    <script src="/blog/scripts/posts.js"></script>
    <script src="/blog/scripts/ArchiveGroup.js"></script>
    <script src="/blog/scripts/header.js"></script>
    <script src="/blog/scripts/comment.js"></script>
    <script src="/blog/scripts/postHandler.js"></script>
    <script src="/blog/scripts/copyright.js"></script>
    <script src="/blog/scripts/bottom.js"></script>
</head>
<body>
<!-- noscript -->
<noscript>
    이 사이트의 기능을 모두 활용하기 위해서는 자바스크립트를 활성화 시킬 필요가 있습니다.
    브라우저에서 자바스크립트를 활성화하는 방법(http://www.enable-javascript.com/ko/)을 참고 하세요.
</noscript>
<!-- container -->
<div class="container" id="viewContainer">
    <!-- content 영역 -->
    <div id="left_wrap" class="col-md-10 col-md-offset-1">
        <!-- 블로그 전문 -->
        <article>
            <!-- 본문 -->
            <div id="content"><p>
                이번엔 Map 인터페이스를 구현한 콜렉션 객체들 중에서도 많이 사용되는 것으로 추정(?)되는 것들을 비교 분석하는 포스트가 되겠습니다.
            </p>

                <h2>Hashtable, HashMap, ConcurrentHashMap</h2>
                <p>
                    위에 나열된 클래스들은 Map 인터페이스를 구현한 콜렉션들입니다. 이 콜렉션들은 비슷한 역할을 하는것 같으면서도 다르게 구현되어 있습니다. 기본적으로 Map 인터페이스를 구축한다면 &lt;key, value>구조를 가지게 됩니다. 하나씩 살펴봅시다.
                </p>

                <h2>Hashtable</h2>
                <p>
                    Hashtable은 <span class="command">put</span>, <span class="command">get</span>과 같은 주요 메소드에 <span class="command">synchronized</span> 키워드가 선언 되어 있습니다. 또한 key, value에 null을 허용하지 않습니다. 아래의 코드는 기본적인 사용법입니다.
                </p>
<pre class="prettyprint lang-java">
package Post197;

import java.util.Hashtable;

public class HashTableBasic {
	public static void main(String[] args) {
		Hashtable&lt;String, Integer> ht = new Hashtable&lt;>();

		ht.put("key", 0);

		/*
		 * Hashtable은 값에 null을 허용하지 않는다.
		 */
		try{
			ht.put("key2", null); // error!
		} catch( Exception e ){
			e.printStackTrace();
		}

		/*
		 * Hashtable은 키값에 null을 허용하지 않는다.
		 */
		try{
			ht.put(null, 0); // error!
		} catch( Exception e ){
			e.printStackTrace();
		}

		// 해당 키 값을 가져온다.
		ht.get("key"); // 0
	}
}
</pre>

                <h2>HashMap</h2>
                <p>
                    HashMap은 주요 메소드에 <span class="command">synchronized</span> 키워드가 <strong>없습니다</strong>. 또한 Hashtable과 다르게 key, value에 null을 입력할 수 있습니다.
                </p>
<pre class="prettyprint lang-java">
package Post197;

import java.util.HashMap;
import java.util.Map.Entry;

public class HashMapBasic {
	public static void main(String[] args) {
		HashMap&lt;String, Integer> hm = new HashMap&lt;>();

		// 값 입력
		hm.put("key", 0);

		// HashMap은 값에 null을 허용한다.
		hm.put("key2", null);

		/*
		 * HashMap은 키값에 null을 허용한다.
		 */
		hm.put(null, 0);

		// 값 출력
		hm.get("key");

		// 반복 처리 with keySet
		for( String s : hm.keySet() ){
			System.out.println(hm.get(s));
		}

		// 반복 처리 with entrySet
		for( Entry&lt;String, Integer> s : hm.entrySet() ){
			System.out.println(s.getKey()+" "+s.getValue());
		}
	}
}
</pre>

                <h2>ConcurrentHashMap</h2>
                <p>
                    HashMap을 thread-safe 하도록 만든 클래스가 ConcurrentHashMap입니다. 하지만 HashMap과는 다르게 key, value에 null을 허용하지 않습니다. 또한 <span class="command">putIfAbsent</span>라는 메소드를 가지고 있습니다. 해당 부분은 아래 코드의 주석을 참고하시기 바랍니다.
                </p>
<pre class="prettyprint lang-java">
package Post197;

import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapBasic {

	public static void main(String[] args) {

		ConcurrentHashMap&lt;String, Integer> chm = new ConcurrentHashMap&lt;>();

		// 값 입력
		chm.put("key", 0);

		/*
		 * ConcurrentHashMap은 값에 null을 허용하지 않는다.
		 */
		try{
			chm.put("key1", null); // error!
		} catch( Exception e ){
			e.printStackTrace();
		}

		/*
		 * ConcurrentHashMap은 키값에 null을 허용하지 않는다.
		 */
		try{
			chm.put(null, 0); // error!
		} catch( Exception e ){
			e.printStackTrace();
		}

		/*
		 * putIfAbsent 메소드는 키값이 존재하면 기존의 값을 반환하고
		 * 없다면 입력한 값을 저장한 뒤 반환한다.
		 * 따라서 아래의 코드는 이미 key라는 값에 0이라는 값이 있으므로
		 * key 값은 0을 반환한다.
		 */
		chm.putIfAbsent("key", 1);

		/*
		 * 아래 코드는 key2의 값이 없기 때문에 -1을 저장하고 반환한다.
		 */
		chm.putIfAbsent("key2", -1);

		for( String s : chm.keySet() ){
			System.out.println(chm.get(s)); // print -1, 0
		}
	}
}
</pre>

                <h2>Common Methods</h2>
                <p>
                    위의 세종류의 클래스들은 <span class="command">put</span>, <span class="command">get</span> 메소드 외에도 기본적인 메소드들을 구현하고 있습니다. 대표적인 몇가지의 메소드들만 알아봅시다.
                </p>
                <ul>
                    <li>
                        <strong>clear()</strong>
                        <p>
                            해당 콜렉션의 데이터를 초기화 합니다.
                        </p>
                    </li>
                    <li>
                        <strong>containsKey(key)</strong>
                        <p>
                            해당 콜렉션에 입력 받은 key를 가지고 있는지 체크합니다.
                        </p>
                    </li>
                    <li>
                        <strong>containsValue(value)</strong>
                        <p>
                            해당 콜렉션에 입력 받은 value를 가지고 있는지 체크합니다.
                        </p>
                    </li>
                    <li>
                        <strong>remove(key)</strong>
                        <p>
                            해당 콜렉션에 입력 받은 key의 데이터(key도 포함)를 제거합니다.
                        </p>
                    </li>
                    <li>
                        <strong>isEmpty()</strong>
                        <p>
                            해당 콜렉션이 비어 있는지 체크합니다.
                        </p>
                    </li>
                    <li>
                        <strong>size()</strong>
                        <p>
                            해당 콜렉션의 엔트리(Entry) 또는 세그먼트(Segment) 사이즈를 반환합니다.
                        </p>
                    </li>
                </ul>

                <h2>In Multi Threads</h2>
                <p>
                    사실, 이 포스트에서 가장 쓰고 싶었던 부분입니다. 위에서 살펴본 기본적인 사항에 의해 각각의 콜렉션들이 조금씩 다르다는 것을 알았습니다. 그리고 그중에서 제가 주의깊게 본 사항은 <strong>동기화</strong> 부분입니다. 실제로 동기화를 위해선 어떤 콜렉션을 써야하는지, 왜 그래야 하는지에 대한 코드 테스트를 진행했습니다.
                </p>
                <p>
                    아래의 코드는 위에서 서술한 콜렉션들을 10개의 스레드에서 각각 1000번을 반복하며 랜덤한 값을 입력할 때 엔트리의 사이즈를 비교하는 코드입니다. (성능 테스트는 아닙니다.)
                </p>
                <p>
                    코드 분석이 귀찮으시다면 아래로 그냥 내리셔도 됩니다! :3
                </p>

<pre class="prettyprint lang-java">
package Post197;

import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class MultiThreadsTest {

	private static final int MAX_THREADS = 10;

	private static Hashtable&lt;String, Integer> ht = new Hashtable&lt;>();
	private static HashMap&lt;String, Integer> hm = new HashMap&lt;>();
	private static HashMap&lt;String, Integer> hmSyn = new HashMap&lt;>();
	private static Map&lt;String, Integer> hmSyn2 = Collections.synchronizedMap(new HashMap&lt;String, Integer>());
	private static ConcurrentHashMap&lt;String, Integer> chm = new ConcurrentHashMap&lt;>();

	public static void main(String[] args) throws InterruptedException {

		ExecutorService es = Executors.newFixedThreadPool(MAX_THREADS);

		for( int j = 0 ; j &lt; MAX_THREADS; j++ ){
			es.execute(new Runnable() {
				@Override
				public void run() {
					for( int i = 0; i &lt; 1000; i++ ){

						String key = String.valueOf(i);

						ht.put(key, i);
						hm.put(key, i);
						chm.put(key, i);
						hmSyn2.put(key, i);

						synchronized (hmSyn) {
							hmSyn.put(key, i);
						}
					}
				}
			});
		}

		es.shutdown();
		try {
			es.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		System.out.println("Hashtable size is "+ ht.size());
		System.out.println("HashMap size is "+ hm.size());
		System.out.println("ConcurrentHashMap size is "+ chm.size());
		System.out.println("HashMap(synchronized) size is "+ hmSyn.size());
		System.out.println("synchronizedMap size is "+ hmSyn2.size());

		/*
		for( String s : hm.keySet() ){
			System.out.println("["+s+"] " + hm.get(s));
		}
		*/
	}
}
</pre>
<pre class="console">
Hashtable size is 1000
HashMap size is 1281
ConcurrentHashMap size is 1000
HashMap(synchronized) size is 1000
synchronizedMap size is 1000
</pre>

                <p>
                    위의 콘솔 결과를 보듯이 HashMap에 대한 부분은 동기화가 이루어지지 않아 엔트리 사이즈가 비정상적으로 나오는 것을 알 수 있습니다. 하지만 HashMap을 쓰더라도 <span class="command">synchronized</span> 블록을 선언해 주면 정상으로 동작을 합니다. 따라서 동기화 이슈가 있다면 일반적인 HashMap을 쓰지 말거나 쓰더라도 동기화를 보장하는 HashMap 콜렉션 또는 <span class="command">synchronized</span> 키워드를 이용해 동기화 처리를 반드시 해주는 것이 좋아보입니다.
                </p>

                <h2>Closing Remarks</h2>
                <p>
                    간단하게 Map 인터페이스를 구현한 콜렉션들의 비교 및 분석을 해봤습니다. 혹시라도 잘못된 점이 있으면 댓글 부탁드립니다. :D
                </p>
            </div>
        </article>
    </div>
    <!-- // content 영역 -->
</div>
<!-- # code highlight -->
<script src="//cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=scala&lang=sql&skin=sons-of-obsidian"></script>
<script src="/lib/scripts/footer.js"></script>
</body>
</html>
